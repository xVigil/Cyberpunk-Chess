<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Cyberpunk Chess — Neon Set</title>
<style>
  :root{
    --bg:#0c0f13;
    --panel:#0f141b;
    --grid1:#141a22;
    --grid2:#10151d;
    --accent1:#00e5ff;   /* cyan */
    --accent2:#ff3da1;   /* magenta */
    --gold:#d3a92f;
    --danger:#ff4b5c;
    --ok:#4bff7a;
    --shadow: 0 8px 30px rgba(0,0,0,.5);
  }
  html,body{height:100%;background:var(--bg);color:#c9d4e0;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:flex;flex-direction:column;gap:16px;align-items:center;justify-content:center;min-height:100%}
  .title{letter-spacing:.5px;font-weight:700;margin-top:8px;text-align:center}
  .desk{display:flex;gap:20px;flex-wrap:wrap;align-items:flex-start;justify-content:center}
  .board{
    width:min(90vw, min(80vh,720px));
    aspect-ratio:1/1;
    border-radius:18px;
    position:relative;
    background:
      radial-gradient(120% 100% at 0% 0%, rgba(0,229,255,.08), transparent 60%),
      radial-gradient(120% 100% at 100% 100%, rgba(255,61,161,.08), transparent 60%),
      /* faint gold "circuit" traces */
      linear-gradient(90deg, transparent 48%, rgba(211,169,47,.08) 50%, transparent 52%) 0 0/40px 40px,
      linear-gradient(0deg,  transparent 48%, rgba(211,169,47,.08) 50%, transparent 52%) 0 0/40px 40px,
      linear-gradient(45deg, transparent 48%, rgba(211,169,47,.06) 50%, transparent 52%) 0 0/80px 80px;
    box-shadow: var(--shadow), 0 0 0 1px rgba(255,255,255,.04) inset;
    padding:10px;
  }
  .grid{display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);height:100%;gap:0;border-radius:12px;overflow:hidden;position:relative}
  .sq{position:relative;user-select:none;display:flex;align-items:center;justify-content:center;cursor:grab;touch-action:none}
  .sq.dark{background:linear-gradient(180deg, var(--grid1), #0b0f15)}
  .sq.light{background:linear-gradient(180deg, var(--grid2), #0a0e13)}
  .sq::after{content:"";position:absolute;inset:0;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03)}
  .sq.coord{font-size:10px;position:absolute;bottom:6px;right:6px;opacity:.5;pointer-events:none}
  .mark{position:absolute;inset:0;box-shadow:inset 0 0 0 2px rgba(0,229,255,.32);border-radius:2px;pointer-events:none}
  .hl{position:absolute;inset:0;background:radial-gradient(circle at 50% 50%, rgba(0,229,255,.14), transparent 60%);pointer-events:none}
  .lastmove{position:absolute;inset:0;background:linear-gradient(180deg, rgba(255,61,161,.08), rgba(0,229,255,.06));mix-blend-mode:screen;pointer-events:none}
  .dragging{opacity:.75;transform:scale(1.05);filter:drop-shadow(0 8px 16px rgba(0,229,255,.3)) drop-shadow(0 16px 32px rgba(255,61,161,.25))}
  .ghost{position:absolute;inset:0;pointer-events:none;border:1px dashed rgba(255,255,255,.1)}

  /* Piece sprites (SVG) as inline components */
  .piece{width:88%;height:88%;display:flex;align-items:center;justify-content:center}
  .spr{width:100%;height:100%;}
  .white .spr{color:var(--accent1)}
  .white .spr .glow{filter:drop-shadow(0 0 6px rgba(0,229,255,.9)) drop-shadow(0 0 18px rgba(0,229,255,.4))}
  .black .spr{color:var(--accent2)}
  .black .spr .glow{filter:drop-shadow(0 0 6px rgba(255,61,161,.9)) drop-shadow(0 0 18px rgba(255,61,161,.4))}

  .panel{
    min-width:300px;max-width:420px;flex:1;
    background:linear-gradient(180deg, var(--panel), #0d1218);
    border-radius:14px;padding:14px;box-shadow:var(--shadow);
  }
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0}
  .btn{
    background:#111823;color:#d9e5f4;border:1px solid rgba(255,255,255,.08);
    padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer;
  }
  .btn:hover{border-color:rgba(255,255,255,.18)}
  .btn.primary{background:linear-gradient(90deg, rgba(0,229,255,.15), rgba(255,61,161,.15));border-color:rgba(0,229,255,.25)}
  .status{font-size:14px;opacity:.9}
  .fen{width:100%;background:#0b1118;border:1px solid rgba(255,255,255,.08);color:#c9d4e0;border-radius:8px;padding:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
  .promo{display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);align-items:center;justify-content:center}
  .promo > div{background:#0f141b;border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:14px;display:grid;grid-template-columns:repeat(4,80px);gap:12px}
  .promo .option{width:80px;height:80px;display:flex;align-items:center;justify-content:center;background:#0b1118;border-radius:10px;border:1px solid rgba(255,255,255,.08);cursor:pointer}
  .promo .option:hover{border-color:rgba(0,229,255,.4)}
  .hint{font-size:12px;opacity:.7;margin-top:4px}
  .credits{opacity:.6;font-size:12px;margin-top:6px}
</style>
</head>
<body>
<div class="wrap">
  <div class="title">CYBERPUNK CHESS — <span style="color:var(--accent1)">Neon</span> vs <span style="color:var(--accent2)">Magenta</span></div>
  <div class="desk">
    <div class="board">
      <div id="grid" class="grid"></div>
      <div id="ghost" class="ghost" hidden></div>
    </div>
    <div class="panel">
      <div class="row">
        <button class="btn primary" id="new">New Game</button>
        <button class="btn" id="flip">Flip Board</button>
        <button class="btn" id="undo">Undo</button>
      </div>
      <div class="row status" id="status">White to move.</div>
      <div class="row">
        <input id="fen" class="fen" value="start" />
        <button class="btn" id="load">Load FEN</button>
        <button class="btn" id="copy">Copy FEN</button>
      </div>
      <div class="hint">Drag pieces. Legal moves glow cyan/magenta. Promotions appear automatically. On iOS Safari, if you don’t see pieces, refresh the page after it loads.</div>
      <div class="credits">Visuals: inline SVG sprites (archetypes: <i>Corpo</i>=King, <i>Netrunner</i>=Queen, <i>Solo</i>=Rook, <i>Biker</i>=Knight, <i>Tech‑priest</i>=Bishop, <i>Drone</i>=Pawn). Swap easily in code.</div>
    </div>
  </div>
</div>

<!-- Sprite Definitions -->
<script>
/* ============================
   Minimal Chess Engine (ES6)
   - Full legal moves
   - Castling, en passant, promotion
   - FEN load/save
   ============================ */
const WHITE = 'w', BLACK = 'b';
const PIECES = { p:'pawn', r:'rook', n:'knight', b:'bishop', q:'queen', k:'king' };

function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

class Game {
  constructor(){ this.loadFEN(this.START_FEN()); this.history=[]; }
  START_FEN(){ return "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"; }
  emptyBoard(){
    const b=[]; for(let r=0;r<8;r++){ b.push(new Array(8).fill(null)); } return b;
  }
  loadFEN(fen){
    if(fen==="start") fen=this.START_FEN();
    const [pos,active,castling,ep,half,full] = fen.split(" ");
    this.board=this.emptyBoard();
    let r=0,c=0;
    for(const ch of pos){
      if(ch==='/'){ r++; c=0; continue; }
      if(Number.isInteger(+ch)){ c+= +ch; continue; }
      const color = ch===ch.toUpperCase()?WHITE:BLACK;
      const type = PIECES[ch.toLowerCase()];
      this.board[r][c]={type, color};
      c++;
    }
    this.turn=active;
    this.castling={K:false,Q:false,k:false,q:false};
    if(castling!=="-"){
      this.castling.K = castling.includes("K");
      this.castling.Q = castling.includes("Q");
      this.castling.k = castling.includes("k");
      this.castling.q = castling.includes("q");
    }
    this.ep = ep==='-'? null : this.algebraToRC(ep);
    this.halfmove = parseInt(half||"0",10);
    this.fullmove = parseInt(full||"1",10);
    this.kingPos = this.findKings();
  }
  toFEN(){
    let pos="";
    for(let r=0;r<8;r++){
      let empty=0;
      for(let c=0;c<8;c++){
        const p=this.board[r][c];
        if(!p){ empty++; continue; }
        if(empty>0){ pos+=empty; empty=0; }
        const ch = this.pieceChar(p);
        pos+=ch;
      }
      if(empty>0) pos+=empty;
      if(r<7) pos+="/";
    }
    let cast = "";
    if(this.castling.K) cast+="K";
    if(this.castling.Q) cast+="Q";
    if(this.castling.k) cast+="k";
    if(this.castling.q) cast+="q";
    if(cast==="") cast="-";
    const ep = this.ep? this.rcToAlgebra(this.ep) : "-";
    return `${pos} ${this.turn} ${cast} ${ep} ${this.halfmove} ${this.fullmove}`;
  }
  pieceChar(p){
    const map={pawn:'p',rook:'r',knight:'n',bishop:'b',queen:'q',king:'k'};
    const ch=map[p.type];
    return p.color===WHITE? ch.toUpperCase(): ch;
  }
  algebraToRC(a){
    const file=a.charCodeAt(0)-97; const rank=8-parseInt(a[1],10);
    return [rank,file];
  }
  rcToAlgebra([r,c]){ return String.fromCharCode(97+c)+(8-r); }
  findKings(){
    let wk=null,bk=null;
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){
      const p=this.board[r][c];
      if(p && p.type==='king'){
        if(p.color===WHITE) wk=[r,c]; else bk=[r,c];
      }
    }
    return {w:wk,b:bk};
  }
  inBounds(r,c){ return r>=0&&r<8&&c>=0&&c<8; }
  isEmpty(r,c){ return this.inBounds(r,c) && !this.board[r][c]; }
  enemy(color){ return color===WHITE?BLACK:WHITE; }

  generateMoves(color=this.turn){
    const moves=[];
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){
      const p=this.board[r][c];
      if(!p || p.color!==color) continue;
      const from=[r,c];
      this.movesFor(p,from,moves);
    }
    // filter out moves that leave king in check
    const legal=[];
    for(const m of moves){
      const snap=this.snapshot();
      this.makeMove(m,true);
      if(!this.isInCheck(color)){
        legal.push(m);
      }
      this.restore(snap);
    }
    return legal;
  }

  movesFor(p,[r,c],out){
    const color=p.color, dir=color===WHITE? -1 : 1;
    const enemy=this.enemy(color);

    const push=(to, extra={})=> out.push({from:[r,c], to, piece:clone(p), ...extra});

    if(p.type==='pawn'){
      const nr=r+dir;
      if(this.isEmpty(nr,c)) {
        // promo?
        if((color===WHITE && nr===0)||(color===BLACK && nr===7)){
          for(const promo of ['queen','rook','bishop','knight']) push([nr,c], {promo});
        }else push([nr,c]);
        // double
        const startRow = color===WHITE? 6:1;
        if(r===startRow && this.isEmpty(r+2*dir,c)) push([r+2*dir,c], {double:true});
      }
      // captures
      for(const dc of [-1,1]){
        const nc=c+dc;
        if(!this.inBounds(nr,nc)) continue;
        const t=this.board[nr][nc];
        if(t && t.color===enemy){
          if((color===WHITE && nr===0)||(color===BLACK && nr===7)){
            for(const promo of ['queen','rook','bishop','knight']) push([nr,nc], {promo, capture:true});
          }else push([nr,nc], {capture:true});
        }
      }
      // en passant
      if(this.ep){
        const [er,ec]=this.ep;
        if(er===nr && Math.abs(ec-c)===1){
          push([er,ec], {enpassant:true, capture:true});
        }
      }
      return;
    }

    if(p.type==='knight'){
      const deltas=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];
      for(const [dr,dc] of deltas){
        const nr=r+dr,nc=c+dc;
        if(!this.inBounds(nr,nc)) continue;
        const t=this.board[nr][nc];
        if(!t || t.color!==color) push([nr,nc], {capture: !!t});
      }
      return;
    }

    const slide=(dirs)=>{
      for(const [dr,dc] of dirs){
        let nr=r+dr, nc=c+dc;
        while(this.inBounds(nr,nc)){
          const t=this.board[nr][nc];
          if(!t){ push([nr,nc]); }
          else{ if(t.color!==color) push([nr,nc], {capture:true}); break; }
          nr+=dr; nc+=dc;
        }
      }
    };

    if(p.type==='bishop'){ slide([[1,1],[1,-1],[-1,1],[-1,-1]]); return; }
    if(p.type==='rook'){ slide([[1,0],[-1,0],[0,1],[0,-1]]); return; }
    if(p.type==='queen'){ slide([[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]); return; }

    if(p.type==='king'){
      for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){
        if(dr===0&&dc===0) continue;
        const nr=r+dr,nc=c+dc;
        if(!this.inBounds(nr,nc)) continue;
        const t=this.board[nr][nc];
        if(!t || t.color!==color) push([nr,nc], {capture: !!t});
      }
      // castling (check through squares + rights + not in check)
      const rights = color===WHITE? ['K','Q'] : ['k','q'];
      // function to test clear and not attacked path
      const pathSafe=(cells)=>{
        for(const [rr,cc] of cells){ if(this.board[rr][cc]) return false; }
        // ensure squares not attacked
        const snap=this.snapshot();
        let safe=true;
        for(const [rr,cc] of [[r,c], ...cells]){
          if(!safe) break;
          // temporarily place king there and test checks
          const tmp=clone(this.board[r][c]);
          this.board[r][c]=null; this.board[rr][cc]=tmp;
          this.kingPos[color]=[rr,cc];
          if(this.attackers(this.enemy(color)).some(a=>a[0]===rr&&a[1]===cc)) safe=false;
          this.board[rr][cc]=null; this.board[r][c]=tmp; this.kingPos=this.findKings();
        }
        this.restore(snap);
        return safe;
      };
      // Kingside
      if(this.castling[rights[0]]){
        const rookC=7, path=[[r,5],[r,6]];
        if(pathSafe(path)) push([r,6], {castle:'K'});
      }
      // Queenside
      if(this.castling[rights[1]]){
        const path=[[r,1],[r,2],[r,3]];
        if(pathSafe(path)) push([r,2], {castle:'Q'});
      }
    }
  }

  attackers(color){
    // return list of squares from which 'color' attacks king of opposite (or all attacked squares by 'color')
    const atks=[];
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){
      const p=this.board[r][c];
      if(!p || p.color!==color) continue;
      const moves=[];
      // use pseudo-legal (no self-check filter)
      if(p.type==='pawn'){
        const dir = color===WHITE? -1 : 1;
        for(const dc of [-1,1]){
          const nr=r+dir,nc=c+dc;
          if(this.inBounds(nr,nc)) atks.push([nr,nc]);
        }
        continue;
      }
      if(p.type==='knight'){
        const deltas=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];
        for(const [dr,dc] of deltas){ const nr=r+dr,nc=c+dc; if(this.inBounds(nr,nc)) atks.push([nr,nc]); }
        continue;
      }
      const slide=(dirs)=>{
        for(const [dr,dc] of dirs){
          let nr=r+dr,nc=c+dc;
          while(this.inBounds(nr,nc)){
            atks.push([nr,nc]);
            if(this.board[nr][nc]) break;
            nr+=dr; nc+=dc;
          }
        }
      };
      if(p.type==='bishop'){ slide([[1,1],[1,-1],[-1,1],[-1,-1]]); continue; }
      if(p.type==='rook'){ slide([[1,0],[-1,0],[0,1],[0,-1]]); continue; }
      if(p.type==='queen'){ slide([[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]); continue; }
      if(p.type==='king'){
        for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){
          if(dr===0&&dc===0) continue;
          const nr=r+dr,nc=c+dc; if(this.inBounds(nr,nc)) atks.push([nr,nc]);
        }
        continue;
      }
    }
    return atks;
  }

  isInCheck(color){
    const king=this.kingPos[color];
    if(!king) return false;
    const enemy=this.enemy(color);
    const atks=this.attackers(enemy);
    return atks.some(([r,c])=> r===king[0] && c===king[1]);
  }

  snapshot(){
    return {
      board: clone(this.board),
      turn: this.turn,
      castling: clone(this.castling),
      ep: this.ep? [...this.ep]: null,
      halfmove: this.halfmove,
      fullmove: this.fullmove,
      kingPos: {w: this.kingPos.w? [...this.kingPos.w]: null, b: this.kingPos.b? [...this.kingPos.b]: null}
    };
  }
  restore(s){ this.board=s.board; this.turn=s.turn; this.castling=s.castling; this.ep=s.ep; this.halfmove=s.halfmove; this.fullmove=s.fullmove; this.kingPos=s.kingPos; }

  makeMove(m, dry=false){
    const {from,to,promo,enpassant,castle,double}=m;
    const [fr,fc]=from,[tr,tc]=to;
    const moved=this.board[fr][fc];
    const target=this.board[tr][tc];

    // update halfmove clock
    if(moved.type==='pawn' || target) this.halfmove=0; else this.halfmove++;

    // clear en passant capture
    if(enpassant){
      const dir = moved.color===WHITE? 1:-1; // captured pawn behind target square
      this.board[tr+dir][tc]=null;
    }

    // move piece
    this.board[tr][tc]=moved;
    this.board[fr][fc]=null;

    // update king position
    if(moved.type==='king'){
      this.kingPos[moved.color]=[tr,tc];
      // lose castling rights
      if(moved.color===WHITE){ this.castling.K=false; this.castling.Q=false; }
      else { this.castling.k=false; this.castling.q=false; }
      // handle castling rook shift
      if(m.castle==='K'){ // king side
        const r=fr; this.board[r][5]=this.board[r][7]; this.board[r][7]=null;
      } else if(m.castle==='Q'){
        const r=fr; this.board[r][3]=this.board[r][0]; this.board[r][0]=null;
      }
    }
    // rook moved -> update rights
    if(moved.type==='rook'){
      if(fr===7&&fc===0) this.castling.Q=false;
      if(fr===7&&fc===7) this.castling.K=false;
      if(fr===0&&fc===0) this.castling.q=false;
      if(fr===0&&fc===7) this.castling.k=false;
    }
    // rook captured -> update rights
    if(target && target.type==='rook'){
      if(tr===7&&tc===0) this.castling.Q=false;
      if(tr===7&&tc===7) this.castling.K=false;
      if(tr===0&&tc===0) this.castling.q=false;
      if(tr===0&&tc===7) this.castling.k=false;
    }

    // en passant square
    this.ep=null;
    if(double){
      const dir = moved.color===WHITE? -1:1;
      this.ep=[fr+dir,fc];
    }

    // promotion transform
    if(promo){
      this.board[tr][tc]={type:promo, color:moved.color};
    }

    if(!dry){
      this.history.push(m);
      if(this.turn===BLACK) this.fullmove++;
      this.turn = this.enemy(this.turn);
    }
  }

  legalMovesFrom(r,c){
    const p=this.board[r][c];
    if(!p || p.color!==this.turn) return [];
    return this.generateMoves(this.turn).filter(m=>m.from[0]===r && m.from[1]===c);
  }

  gameState(){
    const legal=this.generateMoves(this.turn);
    const inCheck=this.isInCheck(this.turn);
    if(legal.length===0){
      return inCheck? (this.turn===WHITE? "Black wins by checkmate" : "White wins by checkmate")
                   : "Draw by stalemate";
    }
    return (this.turn===WHITE? "White" : "Black") + " to move" + (inCheck? " — in check!" : "");
  }
}

/* ============================
   UI / Board
   ============================ */
const grid = document.getElementById('grid');
const statusEl = document.getElementById('status');
const fenInput = document.getElementById('fen');
const ghost = document.getElementById('ghost');
const promoModal = buildPromoModal();

let game = new Game();
let flipped = false;
let lastMoveVis = null;
let drag = null; // {el, from:[r,c], legal:[moves], offset}

function buildBoard(){
  grid.innerHTML = "";
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){
    const idx = r*8+c;
    const sq = document.createElement('div');
    sq.className = 'sq ' + (((r+c)%2===0)?'light':'dark');
    sq.dataset.r = r; sq.dataset.c = c;
    const coord = document.createElement('div');
    coord.className='sq coord';
    coord.textContent = (flipped? (String.fromCharCode(104-c)+ (r+1)) : (String.fromCharCode(97+c)+ (8-r)));
    sq.appendChild(coord);
    grid.appendChild(sq);
  }
  renderPieces();
  updateStatus();
}
function renderPieces(){
  // clear existing pieces
  document.querySelectorAll('.piece').forEach(p=>p.remove());
  // draw pieces
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){
    const pr = flipped? 7-r : r;
    const pc = flipped? 7-c : c;
    const p = game.board[r][c];
    if(!p) continue;
    const sq = grid.children[pr*8+pc];
    const el = pieceElement(p);
    el.dataset.r=r; el.dataset.c=c;
    sq.appendChild(el);
  }
}
function pieceElement(p){
  const el = document.createElement('div');
  el.className = `piece ${p.color===WHITE?'white':'black'}`;
  el.innerHTML = spriteFor(p.type);
  el.draggable=false;
  el.addEventListener('pointerdown', startDrag);
  return el;
}

function spriteFor(type){
  const common = 'class="spr" viewBox="0 0 72 72" preserveAspectRatio="xMidYMid meet"';
  const wrap = (inner)=> `<svg ${common}><g class="glow" fill="none" stroke="currentColor" stroke-width="3" stroke-linejoin="round" stroke-linecap="round">${inner}</g></svg>`;
  switch(type){
    case 'king':
      return wrap(`
        <path d="M28 60 L36 34 L44 60 Z"/>
        <circle cx="36" cy="28" r="6"/>
        <path d="M24 60 H48"/>
        <path d="M18 66 H54"/>
        <path d="M36 20 v-6 M33 16 h6"/>
      `);
    case 'queen':
      return wrap(`
        <ellipse cx="36" cy="36" rx="11" ry="14"/>
        <path d="M25 50 L47 50"/>
        <path d="M22 60 H50"/>
        <path d="M18 66 H54"/>
        <path d="M28 24 C36 14, 36 14, 44 24"/>
      `);
    case 'rook':
      return wrap(`
        <rect x="24" y="28" width="24" height="24" rx="2" ry="2"/>
        <path d="M24 36 H48 M24 44 H48"/>
        <path d="M22 60 H50"/>
        <path d="M18 66 H54"/>
        <path d="M26 28 V22 H30 V28 M34 28 V22 H38 V28 M42 28 V22 H46 V28"/>
      `);
    case 'bishop':
      return wrap(`
        <path d="M36 18 a8 8 0 1 0 .01 0"/>
        <path d="M32 28 L40 36 L32 44 L40 52"/>
        <path d="M24 60 H48"/>
        <path d="M18 66 H54"/>
      `);
    case 'knight':
      return wrap(`
        <path d="M46 50 L28 50 L22 42 L30 30 L44 30 L38 22"/>
        <circle cx="38" cy="24" r="2.5"/>
        <path d="M24 60 H48"/>
        <path d="M18 66 H54"/>
      `);
    case 'pawn':
      return wrap(`
        <circle cx="36" cy="28" r="7"/>
        <path d="M28 50 H44"/>
        <path d="M22 60 H50"/>
        <path d="M18 66 H54"/>
      `);
  }
}


function startDrag(e){
  const el=e.currentTarget;
  const r=+el.dataset.r, c=+el.dataset.c;
  const p=game.board[r][c];
  if(!p || p.color!==game.turn) return;
  const legal=game.legalMovesFrom(r,c);
  drag={el, from:[r,c], legal, startX:e.clientX, startY:e.clientY, startRect:el.getBoundingClientRect()};
  el.setPointerCapture(e.pointerId);
  el.classList.add('dragging');
  markSquares(legal);
  document.addEventListener('pointermove', onDragMove);
  document.addEventListener('pointerup', endDrag);
}

function onDragMove(e){
  if(!drag) return;
  const dx=e.clientX-drag.startX, dy=e.clientY-drag.startY;
  const el=drag.el;
  el.style.transform=`translate(${dx}px, ${dy}px) scale(1.05)`;
  ghost.hidden=false;
}

function endDrag(e){
  if(!drag) return;
  const el=drag.el;
  el.classList.remove('dragging');
  el.style.transform='';
  document.removeEventListener('pointermove', onDragMove);
  document.removeEventListener('pointerup', endDrag);
  ghost.hidden=true;

  // find target square under pointer
  const rect=grid.getBoundingClientRect();
  const x=e.clientX-rect.left, y=e.clientY-rect.top;
  const col=Math.floor(x/ (rect.width/8));
  const row=Math.floor(y/ (rect.height/8));
  let tr = flipped? 7-row : row;
  let tc = flipped? 7-col : col;
  // find legal move matching
  const mv = drag.legal.find(m=> m.to[0]===tr && m.to[1]===tc );
  clearMarks();
  if(!mv){ drag=null; return; }

  // if promotion is needed and not specified, ask UI
  if(game.board[drag.from[0]][drag.from[1]].type==='pawn'){
    const promoRank = (game.turn===WHITE)? 0:7;
    if(mv.to[0]===promoRank && !mv.promo){
      showPromo((pieceType)=>{
        mv.promo = pieceType;
        doMove(mv);
      });
      drag=null;
      return;
    }
  }
  doMove(mv);
  drag=null;
}

function doMove(mv){
  const snap=game.snapshot();
  game.makeMove(mv);
  lastMoveVis = {from: mv.from, to: mv.to};
  renderPieces();
  drawLastMove();
  updateStatus();
}

function drawLastMove(){
  // clear previous lastmove layers
  document.querySelectorAll('.lastmove').forEach(e=>e.remove());
  if(!lastMoveVis) return;
  const from=lastMoveVis.from, to=lastMoveVis.to;
  const idxFrom = (flipped? (7-from[0]) : from[0]) *8 + (flipped? (7-from[1]) : from[1]);
  const idxTo   = (flipped? (7-to[0]) : to[0]) *8 + (flipped? (7-to[1]) : to[1]);
  const lf=document.createElement('div'); lf.className='lastmove';
  const lt=document.createElement('div'); lt.className='lastmove';
  grid.children[idxFrom].appendChild(lf);
  grid.children[idxTo].appendChild(lt);
}

function markSquares(moves){
  clearMarks();
  const uniq = new Set(moves.map(m=> m.to.join(',')));
  for(const key of uniq){
    const [r,c]=key.split(',').map(Number);
    const pr=flipped? 7-r : r, pc=flipped? 7-c : c;
    const sq = grid.children[pr*8+pc];
    const div=document.createElement('div');
    div.className='hl';
    sq.appendChild(div);
  }
  const start = moves[0]?.from;
  if(start){
    const pr=flipped? 7-start[0] : start[0], pc=flipped? 7-start[1] : start[1];
    const sq = grid.children[pr*8+pc];
    const m=document.createElement('div'); m.className='mark'; sq.appendChild(m);
  }
}
function clearMarks(){
  document.querySelectorAll('.hl,.mark').forEach(e=>e.remove());
}

function updateStatus(){
  statusEl.textContent = game.gameState();
  fenInput.value = game.toFEN();
}

function showPromo(cb){
  promoModal.show(cb);
}
function buildPromoModal(){
  const wrap=document.createElement('div');
  wrap.className='promo';
  const inner=document.createElement('div');
  wrap.appendChild(inner);
  document.body.appendChild(wrap);
  const types=['queen','rook','bishop','knight'];
  const render=(color)=>{
    inner.innerHTML="";
    for(const t of types){
      const opt=document.createElement('div');
      opt.className='option';
      const stub=document.createElement('div');
      stub.className = `piece ${color===WHITE?'white':'black'}`;
      stub.innerHTML = spriteFor(t);
      opt.appendChild(stub);
      opt.addEventListener('click',()=>{
        wrap.style.display='none';
        if(wrap._cb) wrap._cb(t);
      });
      inner.appendChild(opt);
    }
  };
  return {
    show(cb){ wrap._cb=cb; render( (game.turn===WHITE)? WHITE:BLACK ); wrap.style.display='flex'; }
  };
}

/* Controls */
document.getElementById('new').addEventListener('click', ()=>{ game=new Game(); lastMoveVis=null; buildBoard(); });
document.getElementById('flip').addEventListener('click', ()=>{ flipped=!flipped; renderPieces(); drawLastMove(); });
document.getElementById('undo').addEventListener('click', ()=>{
  // Simple undo: reload previous FEN by storing snapshots in history as FEN strings
  // We'll capture FEN after every move (already reflected in game.history moves but not FEN list)
  // For simplicity, rebuild from FEN by replaying all but last. Here, we maintain a shadow list.
  if(!window._fens) window._fens=[game.toFEN()];
  if(window._fens.length<=1) return;
  window._fens.pop();
  const fen=window._fens[window._fens.length-1];
  game.loadFEN(fen);
  lastMoveVis=null;
  renderPieces();
  updateStatus();
});
document.getElementById('load').addEventListener('click', ()=>{
  try{
    const fen=fenInput.value.trim();
    game.loadFEN(fen);
    lastMoveVis=null;
    renderPieces(); updateStatus();
  }catch(e){ alert("Invalid FEN"); }
});
document.getElementById('copy').addEventListener('click', async ()=>{
  await navigator.clipboard.writeText(game.toFEN());
  statusEl.textContent="FEN copied!";
  setTimeout(updateStatus,1200);
});

// Maintain FEN timeline for Undo
(function(){
  const origMake = game.makeMove.bind(game);
  game.makeMove = function(mv){
    origMake(mv);
    if(!window._fens) window._fens=[];
    window._fens.push(game.toFEN());
  };
})();

// Initialize
buildBoard();
</script>
</body>
</html>
