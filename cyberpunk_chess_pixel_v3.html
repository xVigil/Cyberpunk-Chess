<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Cyberpunk Chess — Pixel v3</title>
<style>
  :root{
    --bg:#0c0f13; --panel:#0f141b; --grid1:#141a22; --grid2:#10151d;
    --accent1:#00e5ff; --accent2:#ff3da1; --gold:#d3a92f; --shadow:0 8px 30px rgba(0,0,0,.5);
  }
  html,body{height:100%;background:var(--bg);color:#c9d4e0;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:flex;flex-direction:column;gap:16px;align-items:center;justify-content:center;min-height:100%}
  .title{letter-spacing:.5px;font-weight:700;margin-top:8px;text-align:center}
  .desk{display:flex;gap:20px;flex-wrap:wrap;align-items:flex-start;justify-content:center}
  .board{width:min(90vw, min(80vh,720px));aspect-ratio:1/1;border-radius:18px;position:relative;
    background:
      radial-gradient(120% 100% at 0% 0%, rgba(0,229,255,.08), transparent 60%),
      radial-gradient(120% 100% at 100% 100%, rgba(255,61,161,.08), transparent 60%),
      linear-gradient(90deg, transparent 48%, rgba(211,169,47,.08) 50%, transparent 52%) 0 0/40px 40px,
      linear-gradient(0deg,  transparent 48%, rgba(211,169,47,.08) 50%, transparent 52%) 0 0/40px 40px,
      linear-gradient(45deg, transparent 48%, rgba(211,169,47,.06) 50%, transparent 52%) 0 0/80px 80px;
    box-shadow: var(--shadow), 0 0 0 1px rgba(255,255,255,.04) inset; padding:10px;}
  .grid{display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);height:100%;gap:0;border-radius:12px;overflow:hidden;position:relative}
  .sq{position:relative;user-select:none;display:flex;align-items:center;justify-content:center;touch-action:none}
  .sq.dark{background:linear-gradient(180deg, var(--grid1), #0b0f15)}
  .sq.light{background:linear-gradient(180deg, var(--grid2), #0a0e13)}
  .sq::after{content:"";position:absolute;inset:0;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03)}
  .sq.coord{font-size:10px;position:absolute;bottom:6px;right:6px;opacity:.5;pointer-events:none}
  .mark{position:absolute;inset:0;box-shadow:inset 0 0 0 2px rgba(0,229,255,.32);border-radius:2px;pointer-events:none}
  .hl{position:absolute;inset:0;background:radial-gradient(circle at 50% 50%, rgba(0,229,255,.14), transparent 60%);pointer-events:none}
  .lastmove{position:absolute;inset:0;background:linear-gradient(180deg, rgba(255,61,161,.08), rgba(0,229,255,.06));mix-blend-mode:screen;pointer-events:none}
  .ghost{position:absolute;inset:0;pointer-events:none;border:1px dashed rgba(255,255,255,.1)}
  .piece{width:90%;height:90%;display:flex;align-items:center;justify-content:center;image-rendering: pixelated}
  .px{width:100%;height:100%}
  .panel{min-width:300px;max-width:460px;flex:1;background:linear-gradient(180deg, var(--panel), #0d1218);border-radius:14px;padding:14px;box-shadow:var(--shadow);}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0}
  .btn{background:#111823;color:#d9e5f4;border:1px solid rgba(255,255,255,.08);padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer;}
  .btn:hover{border-color:rgba(255,255,255,.18)}
  .btn.primary{background:linear-gradient(90deg, rgba(0,229,255,.15), rgba(255,61,161,.15));border-color:rgba(0,229,255,.25)}
  .status{font-size:14px;opacity:.9}
  .fen{width:100%;background:#0b1118;border:1px solid rgba(255,255,255,.08);color:#c9d4e0;border-radius:8px;padding:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
  .promo{display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);align-items:center;justify-content:center}
  .promo > div{background:#0f141b;border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:14px;display:grid;grid-template-columns:repeat(4,80px);gap:12px}
  .promo .option{width:80px;height:80px;display:flex;align-items:center;justify-content:center;background:#0b1118;border-radius:10px;border:1px solid rgba(255,255,255,.08);cursor:pointer}
  .promo .option:hover{border-color:rgba(0,229,255,.4)}
  .hint{font-size:12px;opacity:.7;margin-top:4px}
  .credits{opacity:.6;font-size:12px;margin-top:6px}
  .tapbadge{font-size:12px;opacity:.8;padding:4px 8px;border:1px solid rgba(255,255,255,.1);border-radius:8px}
  .label{font-size:11px;opacity:.7}
</style>
</head>
<body>
<div class="wrap">
  <div class="title">CYBERPUNK CHESS — <span style="color:var(--accent1)">Corpos</span> vs <span style="color:var(--accent2)">Heroes</span> <span class="label">(16×16 pixel art)</span></div>
  <div class="desk">
    <div class="board">
      <div id="grid" class="grid"></div>
      <div id="ghost" class="ghost" hidden></div>
    </div>
    <div class="panel">
      <div class="row">
        <button class="btn primary" id="new">New Game</button>
        <button class="btn" id="flip">Flip Board</button>
        <button class="btn" id="undo">Undo</button>
        <button class="btn" id="ai">AI: Off</button>
        <div id="mode" class="tapbadge" hidden>Tap-to-move</div>
      </div>
      <div class="row status" id="status">White (Corpos) to move.</div>
      <div class="row">
        <input id="fen" class="fen" value="start" />
        <button class="btn" id="load">Load FEN</button>
        <button class="btn" id="copy">Copy FEN</button>
      </div>
      <div class="hint">On mobile: tap a piece then tap a destination. (iOS has no true haptics for web; we vibrate when available and play a soft tick.)</div>
      <div class="credits">Black side (Heroes): Johnny (K), Rogue (Q), Jackie (R), Vic (B), Takemura (N), V (P). White side (Corpos): Saburo (K), Smasher (Q), Yorinobu (R), Hellman (B), Oda (N), Alt (P).</div>
    </div>
  </div>
</div>

<script>
/* ===== Utility: haptics/sound ===== */
const canVibrate = 'vibrate' in navigator;
let audioCtx=null;
function tick(){ // soft click using WebAudio
  try{
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
    o.frequency.value=220; g.gain.value=0.05;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); setTimeout(()=>{o.stop();}, 35);
  }catch(e){/* no-op */}
}
function haptic(){ if(canVibrate) navigator.vibrate(10); else tick(); }

/* ===== Chess engine (same as v2, trimmed) ===== */
const WHITE='w', BLACK='b';
const PIECES = { p:'pawn', r:'rook', n:'knight', b:'bishop', q:'queen', k:'king' };
function clone(o){ return JSON.parse(JSON.stringify(o)); }
class Game{
  constructor(){ this.loadFEN(this.START_FEN()); this.history=[]; }
  START_FEN(){ return "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"; }
  emptyBoard(){ const b=[]; for(let r=0;r<8;r++){ b.push(new Array(8).fill(null)); } return b; }
  loadFEN(fen){
    if(fen==="start") fen=this.START_FEN();
    const [pos,active,castling,ep,half,full] = fen.split(" ");
    this.board=this.emptyBoard(); let r=0,c=0;
    for(const ch of pos){
      if(ch==='/'){ r++; c=0; continue; }
      if(Number.isInteger(+ch)){ c+= +ch; continue; }
      const color = ch===ch.toUpperCase()?WHITE:BLACK;
      const type = PIECES[ch.toLowerCase()];
      this.board[r][c]={type, color}; c++;
    }
    this.turn=active;
    this.castling={K:false,Q:false,k:false,q:false};
    if(castling!=="-"){ this.castling.K=castling.includes("K"); this.castling.Q=castling.includes("Q"); this.castling.k=castling.includes("k"); this.castling.q=castling.includes("q"); }
    this.ep = ep==='-'? null : this.algebraToRC(ep);
    this.halfmove=parseInt(half||"0",10); this.fullmove=parseInt(full||"1",10);
    this.kingPos=this.findKings();
  }
  toFEN(){
    let pos=""; for(let r=0;r<8;r++){ let empty=0; for(let c=0;c<8;c++){ const p=this.board[r][c];
      if(!p){ empty++; continue; } if(empty>0){ pos+=empty; empty=0; }
      const ch=this.pieceChar(p); pos+=ch; } if(empty>0) pos+=empty; if(r<7) pos+="/"; }
    let cast=""; if(this.castling.K) cast+="K"; if(this.castling.Q) cast+="Q"; if(this.castling.k) cast+="k"; if(this.castling.q) cast+="q"; if(cast==="") cast="-";
    const ep=this.ep? this.rcToAlgebra(this.ep): "-"; return `${pos} ${this.turn} ${cast} ${ep} ${this.halfmove} ${this.fullmove}`;
  }
  pieceChar(p){ const map={pawn:'p',rook:'r',knight:'n',bishop:'b',queen:'q',king:'k'}; const ch=map[p.type]; return p.color===WHITE? ch.toUpperCase(): ch; }
  algebraToRC(a){ const file=a.charCodeAt(0)-97; const rank=8-parseInt(a[1],10); return [rank,file]; }
  rcToAlgebra([r,c]){ return String.fromCharCode(97+c)+(8-r); }
  findKings(){ let wk=null,bk=null; for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=this.board[r][c]; if(p && p.type==='king'){ if(p.color===WHITE) wk=[r,c]; else bk=[r,c]; } } return {w:wk,b:bk}; }
  inBounds(r,c){ return r>=0&&r<8&&c>=0&&c<8; } isEmpty(r,c){ return this.inBounds(r,c) && !this.board[r][c]; } enemy(color){ return color===WHITE?BLACK:WHITE; }
  generateMoves(color=this.turn){
    const moves=[];
    for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=this.board[r][c]; if(!p || p.color!==color) continue; this.movesFor(p,[r,c],moves); }
    const legal=[]; for(const m of moves){ const s=this.snapshot(); this.makeMove(m,true); if(!this.isInCheck(color)) legal.push(m); this.restore(s); }
    return legal;
  }
  movesFor(p,[r,c],out){
    const color=p.color, dir=color===WHITE? -1 : 1; const enemy=this.enemy(color);
    const push=(to, extra={})=> out.push({from:[r,c], to, piece:clone(p), ...extra});
    if(p.type==='pawn'){
      const nr=r+dir; if(this.isEmpty(nr,c)){ if((color===WHITE&&nr===0)||(color===BLACK&&nr===7)){ for(const promo of ['queen','rook','bishop','knight']) push([nr,c], {promo}); }else push([nr,c]);
        const startRow=color===WHITE?6:1; if(r===startRow && this.isEmpty(r+2*dir,c)) push([r+2*dir,c], {double:true}); }
      for(const dc of [-1,1]){ const nc=c+dc; if(!this.inBounds(nr,nc)) continue; const t=this.board[nr][nc]; if(t && t.color===enemy){ if((color===WHITE&&nr===0)||(color===BLACK&&nr===7)){ for(const promo of ['queen','rook','bishop','knight']) push([nr,nc], {promo,capture:true}); } else push([nr,nc], {capture:true}); } }
      if(this.ep){ const [er,ec]=this.ep; if(er===nr && Math.abs(ec-c)===1) push([er,ec], {enpassant:true,capture:true}); } return;
    }
    if(p.type==='knight'){ const deltas=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]];
      for(const [dr,dc] of deltas){ const nr=r+dr,nc=c+dc; if(!this.inBounds(nr,nc)) continue; const t=this.board[nr][nc]; if(!t || t.color!==color) push([nr,nc], {capture:!!t}); } return; }
    const slide=(dirs)=>{ for(const [dr,dc] of dirs){ let nr=r+dr,nc=c+dc; while(this.inBounds(nr,nc)){ const t=this.board[nr][nc]; if(!t) push([nr,nc]); else { if(t.color!==color) push([nr,nc], {capture:true}); break; } nr+=dr; nc+=dc; } } };
    if(p.type==='bishop'){ slide([[1,1],[1,-1],[-1,1],[-1,-1]]); return; }
    if(p.type==='rook'){ slide([[1,0],[-1,0],[0,1],[0,-1]]); return; }
    if(p.type==='queen'){ slide([[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]); return; }
    if(p.type==='king'){
      for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(!this.inBounds(nr,nc)) continue; const t=this.board[nr][nc]; if(!t || t.color!==color) push([nr,nc], {capture:!!t}); }
      const rights=color===WHITE?['K','Q']:['k','q'];
      const pathSafe=(cells)=>{ for(const [rr,cc] of cells){ if(this.board[rr][cc]) return false; } const s=this.snapshot(); let safe=true;
        for(const [rr,cc] of [[r,c],...cells]){ if(!safe) break; const tmp=clone(this.board[r][c]); this.board[r][c]=null; this.board[rr][cc]=tmp; this.kingPos[color]=[rr,cc];
          if(this.attackers(this.enemy(color)).some(a=>a[0]===rr&&a[1]===cc)) safe=false; this.board[rr][cc]=null; this.board[r][c]=tmp; this.kingPos=this.findKings(); } this.restore(s); return safe; };
      if(this.castling[rights[0]]){ const path=[[r,5],[r,6]]; if(pathSafe(path)) push([r,6], {castle:'K'}); }
      if(this.castling[rights[1]]){ const path=[[r,1],[r,2],[r,3]]; if(pathSafe(path)) push([r,2], {castle:'Q'}); }
    }
  }
  attackers(color){
    const atks=[]; for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=this.board[r][c]; if(!p || p.color!==color) continue;
      if(p.type==='pawn'){ const dir=color===WHITE?-1:1; for(const dc of [-1,1]){ const nr=r+dir,nc=c+dc; if(this.inBounds(nr,nc)) atks.push([nr,nc]); } continue; }
      if(p.type==='knight'){ const ds=[[2,1],[1,2],[-1,2],[-2,1],[-2,-1],[-1,-2],[1,-2],[2,-1]]; for(const [dr,dc] of ds){ const nr=r+dr,nc=c+dc; if(this.inBounds(nr,nc)) atks.push([nr,nc]); } continue; }
      const slide=(dirs)=>{ for(const [dr,dc] of dirs){ let nr=r+dr,nc=c+dc; while(this.inBounds(nr,nc)){ atks.push([nr,nc]); if(this.board[nr][nc]) break; nr+=dr; nc+=dc; } } };
      if(p.type==='bishop'){ slide([[1,1],[1,-1],[-1,1],[-1,-1]]); continue; }
      if(p.type==='rook'){ slide([[1,0],[-1,0],[0,1],[0,-1]]); continue; }
      if(p.type==='queen'){ slide([[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]); continue; }
      if(p.type==='king'){ for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0) continue; const nr=r+dr,nc=c+dc; if(this.inBounds(nr,nc)) atks.push([nr,nc]); } continue; }
    } return atks;
  }
  isInCheck(color){ const king=this.kingPos[color]; if(!king) return false; const enemy=this.enemy(color); const atks=this.attackers(enemy); return atks.some(([r,c])=> r===king[0] && c===king[1]); }
  snapshot(){ return {board:clone(this.board), turn:this.turn, castling:clone(this.castling), ep:this.ep? [...this.ep]:null, halfmove:this.halfmove, fullmove:this.fullmove, kingPos:{w:this.kingPos.w?[...this.kingPos.w]:null, b:this.kingPos.b?[...this.kingPos.b]:null}}; }
  restore(s){ this.board=s.board; this.turn=s.turn; this.castling=s.castling; this.ep=s.ep; this.halfmove=s.halfmove; this.fullmove=s.fullmove; this.kingPos=s.kingPos; }
  makeMove(m, dry=false){
    const {from,to,promo,enpassant,castle,double}=m; const [fr,fc]=from,[tr,tc]=to;
    const moved=this.board[fr][fc]; const target=this.board[tr][tc];
    if(moved.type==='pawn' || target) this.halfmove=0; else this.halfmove++;
    if(enpassant){ const dir=moved.color===WHITE?1:-1; this.board[tr+dir][tc]=null; }
    this.board[tr][tc]=moved; this.board[fr][fc]=null;
    if(moved.type==='king'){ this.kingPos[moved.color]=[tr,tc];
      if(moved.color===WHITE){ this.castling.K=false; this.castling.Q=false; } else { this.castling.k=false; this.castling.q=false; }
      if(m.castle==='K'){ const r=fr; this.board[r][5]=this.board[r][7]; this.board[r][7]=null; } else if(m.castle==='Q'){ const r=fr; this.board[r][3]=this.board[r][0]; this.board[r][0]=null; } }
    if(moved.type==='rook'){ if(fr===7&&fc===0) this.castling.Q=false; if(fr===7&&fc===7) this.castling.K=false; if(fr===0&&fc===0) this.castling.q=false; if(fr===0&&fc===7) this.castling.k=false; }
    if(target&&target.type==='rook'){ if(tr===7&&tc===0) this.castling.Q=false; if(tr===7&&tc===7) this.castling.K=false; if(tr===0&&tc===0) this.castling.q=false; if(tr===0&&tc===7) this.castling.k=false; }
    this.ep=null; if(double){ const dir=moved.color===WHITE?-1:1; this.ep=[fr+dir,fc]; }
    if(promo){ this.board[tr][tc]={type:promo, color:moved.color}; }
    if(!dry){ this.history.push(m); if(this.turn===BLACK) this.fullmove++; this.turn=this.enemy(this.turn); }
  }
  legalMovesFrom(r,c){ const p=this.board[r][c]; if(!p || p.color!==this.turn) return []; return this.generateMoves(this.turn).filter(m=>m.from[0]===r && m.from[1]===c); }
  gameState(){ const legal=this.generateMoves(this.turn); const inCheck=this.isInCheck(this.turn);
    if(legal.length===0){ return inCheck? (this.turn===WHITE? "Black wins by checkmate" : "White wins by checkmate") : "Draw by stalemate"; }
    return (this.turn===WHITE? "White" : "Black") + " to move" + (inCheck? " — in check!" : ""); }
}

/* ===== Pixel sprites (16x16 SVG) ===== */
/* We'll use an ultra-simple pattern per character to keep it readable at 16x16. 
   Colors chosen to hint at character themes. You can replace patterns later. */
const PALETTES={
  cyan:"#00e5ff", mag:"#ff3da1", gold:"#d3a92f", steel:"#9eb0c4", red:"#ff4050",
  green:"#68ff98", amber:"#ffce54", violet:"#a98bff", dark:"#0c0f13", mid:"#1b242f", light:"#d9e5f4"
};
function pxSVG(pixels){ // pixels = 16x16 array of color strings or null
  let out = '<svg class="px" viewBox="0 0 16 16" shape-rendering="crispEdges">';
  for(let y=0;y<16;y++)for(let x=0;x<16;x++){
    const col = pixels[y][x]; if(!col) continue;
    out += `<rect x="${x}" y="${y}" width="1" height="1" fill="${col}"/>`;
  }
  out += '</svg>'; return out;
}
function empty(){ const a=[]; for(let y=0;y<16;y++){ a.push(new Array(16).fill(null)); } return a; }
function put(px,x,y,w,h,col){ for(let j=0;j<h;j++) for(let i=0;i<w;i++){ if(x+i>=0&&x+i<16&&y+j>=0&&y+j<16) px[y+j][x+i]=col; } }
function outline(px,col){
  // simple 1px outline around non-null cells
  for(let y=0;y<16;y++)for(let x=0;x<16;x++){
    if(!px[y][x]) continue;
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if(nx>=0&&nx<16&&ny>=0&&ny<16 && !px[ny][nx]) px[ny][nx] = PALETTES.dark;
    });
  }
}
/* Primitive sprite builders (silhouette + accent) */
function buildKing(accent){ const p=empty(); put(p,5,3,6,8,PALETTES.steel); put(p,7,1,2,2,accent); put(p,4,12,8,1,accent); outline(p,accent); return p; }
function buildQueen(accent){ const p=empty(); put(p,5,4,6,7,PALETTES.violet); put(p,4,11,8,1,accent); put(p,3,13,10,1,accent); outline(p,accent); return p; }
function buildRook(accent){ const p=empty(); put(p,4,6,8,6,PALETTES.steel); put(p,4,5,8,1,accent); put(p,4,12,8,1,accent); outline(p,accent); return p; }
function buildBishop(accent){ const p=empty(); put(p,6,4,4,8,PALETTES.green); put(p,7,3,2,1,accent); put(p,5,13,6,1,accent); outline(p,accent); return p; }
function buildKnight(accent){ const p=empty(); put(p,4,5,8,6,PALETTES.red); put(p,9,4,2,2,PALETTES.dark); put(p,3,12,10,1,accent); outline(p,accent); return p; }
function buildPawn(accent){ const p=empty(); put(p,6,6,4,4,PALETTES.gold); put(p,5,11,6,1,accent); outline(p,accent); return p; }

// Character-to-sprite mapping (by side/piece)
const HERO = { // black side
  king:   pxSVG(buildKing(PALETTES.mag)),     // Johnny
  queen:  pxSVG(buildQueen(PALETTES.mag)),    // Rogue
  rook:   pxSVG(buildRook(PALETTES.mag)),     // Jackie
  bishop: pxSVG(buildBishop(PALETTES.mag)),   // Vic
  knight: pxSVG(buildKnight(PALETTES.mag)),   // Takemura
  pawn:   pxSVG(buildPawn(PALETTES.mag))      // V
};
const CORPO = { // white side
  king:   pxSVG(buildKing(PALETTES.cyan)),    // Saburo
  queen:  pxSVG(buildQueen(PALETTES.cyan)),   // Adam Smasher
  rook:   pxSVG(buildRook(PALETTES.cyan)),    // Yorinobu
  bishop: pxSVG(buildBishop(PALETTES.cyan)),  // Hellman
  knight: pxSVG(buildKnight(PALETTES.cyan)),  // Oda
  pawn:   pxSVG(buildPawn(PALETTES.cyan))     // Alt
};

/* ===== UI ===== */
const grid=document.getElementById('grid');
const statusEl=document.getElementById('status');
const fenInput=document.getElementById('fen');
const ghost=document.getElementById('ghost');
const tapBadge=document.getElementById('mode');
const aiBtn=document.getElementById('ai');

let game=new Game(); let flipped=false; let lastMoveVis=null; let tapSel=null; let aiOn=false; window._fens=[];

function buildBoard(){
  grid.innerHTML="";
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){
    const sq=document.createElement('div'); sq.className='sq '+(((r+c)%2===0)?'light':'dark');
    sq.dataset.r=r; sq.dataset.c=c;
    const coord=document.createElement('div'); coord.className='sq coord';
    coord.textContent=(flipped? (String.fromCharCode(104-c)+(r+1)) : (String.fromCharCode(97+c)+(8-r)));
    sq.appendChild(coord);
    sq.addEventListener('click', onSquareTap, {passive:true});
    grid.appendChild(sq);
  }
  renderPieces(); updateStatus();
}

function renderPieces(){
  document.querySelectorAll('.piece').forEach(p=>p.remove());
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){
    const pr=flipped? 7-r : r; const pc=flipped? 7-c : c;
    const p=game.board[r][c]; if(!p) continue;
    const sq=grid.children[pr*8+pc];
    const el=document.createElement('div'); el.className='piece';
    const sprite = (p.color===WHITE? CORPO : HERO)[p.type];
    el.innerHTML = sprite;
    el.dataset.r=r; el.dataset.c=c;
    sq.appendChild(el);
  }
}

function clearMarks(){ document.querySelectorAll('.hl,.mark').forEach(e=>e.remove()); }
function markSquares(moves){
  clearMarks(); const uniq=new Set(moves.map(m=>m.to.join(',')));
  for(const key of uniq){ const [r,c]=key.split(',').map(Number); const pr=flipped? 7-r:r, pc=flipped? 7-c:c;
    const sq=grid.children[pr*8+pc]; const div=document.createElement('div'); div.className='hl'; sq.appendChild(div); }
  if(moves[0]){ const s=moves[0].from; const pr=flipped? 7-s[0]:s[0], pc=flipped? 7-s[1]:s[1]; const sq=grid.children[pr*8+pc]; const m=document.createElement('div'); m.className='mark'; sq.appendChild(m); }
}
function drawLastMove(){
  document.querySelectorAll('.lastmove').forEach(e=>e.remove());
  if(!lastMoveVis) return; const from=lastMoveVis.from, to=lastMoveVis.to;
  const idxFrom=(flipped?(7-from[0]):from[0])*8+(flipped?(7-from[1]):from[1]); const idxTo=(flipped?(7-to[0]):to[0])*8+(flipped?(7-to[1]):to[1]);
  const lf=document.createElement('div'); lf.className='lastmove'; const lt=document.createElement('div'); lt.className='lastmove';
  grid.children[idxFrom].appendChild(lf); grid.children[idxTo].appendChild(lt);
}
function updateStatus(){ statusEl.textContent=game.gameState(); fenInput.value=game.toFEN(); }

function onSquareTap(e){
  const sq=e.currentTarget; const vr=+sq.dataset.r, vc=+sq.dataset.c; const r=flipped? 7-vr: vr, c=flipped? 7-vc: vc;
  if(!tapSel){
    const p=game.board[r][c]; if(!p || p.color!==game.turn) return;
    const legal=game.legalMovesFrom(r,c); if(legal.length===0) return;
    tapSel={r,c,legal}; markSquares(legal); haptic(); return;
  } else {
    const mv=tapSel.legal.find(m=> m.to[0]===r && m.to[1]===c );
    clearMarks(); tapSel=null; if(mv){ handleMove(mv); }
  }
}

function showPromo(cb){
  let wrap=document.querySelector('.promo'); if(!wrap){ wrap=document.createElement('div'); wrap.className='promo'; const inner=document.createElement('div'); wrap.appendChild(inner); document.body.appendChild(wrap); }
  const inner=wrap.firstElementChild; inner.innerHTML="";
  for(const t of ['queen','rook','bishop','knight']){
    const opt=document.createElement('div'); opt.className='option';
    const side = game.turn===WHITE? CORPO : HERO; const stub=document.createElement('div'); stub.className='piece'; stub.innerHTML=side[t];
    opt.appendChild(stub); opt.addEventListener('click',()=>{ wrap.style.display='none'; cb(t); haptic(); });
    inner.appendChild(opt);
  }
  wrap.style.display='flex';
}

function handleMove(mv){
  if(game.board[mv.from[0]][mv.from[1]].type==='pawn'){
    const promoRank = (game.turn===WHITE)? 0:7; if(mv.to[0]===promoRank && !mv.promo){ return showPromo((pieceType)=>{ mv.promo=pieceType; doMove(mv); }); }
  }
  doMove(mv);
}

function doMove(mv){
  window._fens.push(game.toFEN());
  game.makeMove(mv); lastMoveVis={from: mv.from, to: mv.to};
  renderPieces(); drawLastMove(); updateStatus(); haptic();
  if(aiOn) maybeAIMove();
}

/* Simple AI (negamax with material eval, depth=2 by default) */
const VALUES = {pawn:100, knight:320, bishop:330, rook:500, queen:900, king:0};
function evaluate(g){
  let score=0;
  for(let r=0;r<8;r++)for(let c=0;c<8;c++){ const p=g.board[r][c]; if(!p) continue; const v=VALUES[p.type]; score += (p.color===WHITE? v : -v); }
  return (g.turn===WHITE? 1 : -1) * score; // score from side-to-move perspective
}
function bestMove(depth=2){
  const color=game.turn;
  const moves=game.generateMoves(color);
  let best=null, bestScore=-1e9;
  for(const m of moves){
    const s=game.snapshot(); game.makeMove(m,true);
    const sc = -negamax(depth-1, -1e9, 1e9);
    game.restore(s);
    if(sc>bestScore){ bestScore=sc; best=m; }
  }
  return best || moves[0] || null;
}
function negamax(depth, alpha, beta){
  if(depth===0) return evaluate(game);
  const color=game.turn; const moves=game.generateMoves(color); if(moves.length===0) return evaluate(game);
  let value=-1e9;
  for(const m of moves){
    const s=game.snapshot(); game.makeMove(m,true);
    const score = -negamax(depth-1, -beta, -alpha);
    game.restore(s);
    if(score>value) value=score;
    if(value>alpha) alpha=value;
    if(alpha>=beta) break;
  }
  return value;
}
function maybeAIMove(){
  // AI will move for the side opposite the human's last move. Toggle plays for side-to-move.
  setTimeout(()=>{
    if(!aiOn) return;
    const mv=bestMove(2);
    if(mv){ doMove(mv); }
  }, 200);
}

/* Controls */
document.getElementById('new').addEventListener('click', ()=>{ game=new Game(); lastMoveVis=null; tapSel=null; window._fens=[game.toFEN()]; renderPieces(); buildBoard(); });
document.getElementById('flip').addEventListener('click', ()=>{ flipped=!flipped; renderPieces(); drawLastMove(); });
document.getElementById('undo').addEventListener('click', ()=>{ if(window._fens.length<=1) return; window._fens.pop(); const fen=window._fens[window._fens.length-1]; game.loadFEN(fen); lastMoveVis=null; tapSel=null; renderPieces(); updateStatus(); });
document.getElementById('load').addEventListener('click', ()=>{ try{ const fen=fenInput.value.trim(); game.loadFEN(fen); lastMoveVis=null; tapSel=null; window._fens=[game.toFEN()]; renderPieces(); updateStatus(); } catch(e){ alert("Invalid FEN"); } });
document.getElementById('copy').addEventListener('click', async ()=>{ await navigator.clipboard.writeText(game.toFEN()); statusEl.textContent="FEN copied!"; setTimeout(updateStatus,1200); });
aiBtn.addEventListener('click', ()=>{ aiOn=!aiOn; aiBtn.textContent = "AI: " + (aiOn? "On" : "Off"); if(aiOn) maybeAIMove(); haptic(); });

/* Init */
function init(){ buildBoard(); window._fens=[game.toFEN()]; if('ontouchstart' in window){ tapBadge.hidden=false; } }
init();
</script>
</body>
</html>
